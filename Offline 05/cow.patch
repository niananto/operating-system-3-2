diff --git a/Offline 05/xv6-riscv/kernel/defs.h b/Offline 05/xv6-riscv/kernel/defs.h
index a3c962b..3eaece5 100644
--- a/Offline 05/xv6-riscv/kernel/defs.h	
+++ b/Offline 05/xv6-riscv/kernel/defs.h	
@@ -63,6 +63,8 @@ void            ramdiskrw(struct buf*);
 void*           kalloc(void);
 void            kfree(void *);
 void            kinit(void);
+void            add_rc(uint64);
+void            sub_rc(uint64);
 
 // log.c
 void            initlog(int, struct superblock*);
diff --git a/Offline 05/xv6-riscv/kernel/kalloc.c b/Offline 05/xv6-riscv/kernel/kalloc.c
index 0699e7e..3030f39 100644
--- a/Offline 05/xv6-riscv/kernel/kalloc.c	
+++ b/Offline 05/xv6-riscv/kernel/kalloc.c	
@@ -9,6 +9,21 @@
 #include "riscv.h"
 #include "defs.h"
 
+// KERNBASE == 0x80000000
+static int reference_count[(PHYSTOP - KERNBASE) / PGSIZE];
+
+static int idx_rc(uint64 pa) { // get reference count index
+  return (pa - KERNBASE) / PGSIZE;
+}
+
+void add_rc(uint64 pa) { // add reference count
+  reference_count[idx_rc(pa)]++;
+}
+
+void sub_rc(uint64 pa) { // subtract reference count
+  reference_count[idx_rc(pa)]--;
+}
+
 void freerange(void *pa_start, void *pa_end);
 
 extern char end[]; // first address after kernel.
@@ -50,7 +65,10 @@ kfree(void *pa)
 
   if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
     panic("kfree");
-
+  if(reference_count[idx_rc((uint64)pa)] > 1) { // >1 just sub 1
+    sub_rc((uint64)pa);
+    return;
+  }
   // Fill with junk to catch dangling refs.
   memset(pa, 1, PGSIZE);
 
@@ -60,6 +78,7 @@ kfree(void *pa)
   r->next = kmem.freelist;
   kmem.freelist = r;
   release(&kmem.lock);
+  reference_count[idx_rc((uint64)pa)] = 0;
 }
 
 // Allocate one 4096-byte page of physical memory.
@@ -78,5 +97,10 @@ kalloc(void)
 
   if(r)
     memset((char*)r, 5, PGSIZE); // fill with junk
+  
+  // initialize reference count to 1 when allocating pages
+  if(r)
+    reference_count[idx_rc((uint64)r)] = 1;
+
   return (void*)r;
 }
diff --git a/Offline 05/xv6-riscv/kernel/riscv.h b/Offline 05/xv6-riscv/kernel/riscv.h
index 20a01db..a51956a 100644
--- a/Offline 05/xv6-riscv/kernel/riscv.h	
+++ b/Offline 05/xv6-riscv/kernel/riscv.h	
@@ -344,6 +344,8 @@ typedef uint64 *pagetable_t; // 512 PTEs
 #define PTE_X (1L << 3)
 #define PTE_U (1L << 4) // user can access
 
+#define PTE_RSW (1L << 8)
+
 // shift a physical address to the right place for a PTE.
 #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
 
diff --git a/Offline 05/xv6-riscv/kernel/trap.c b/Offline 05/xv6-riscv/kernel/trap.c
index 512c850..c24cb06 100644
--- a/Offline 05/xv6-riscv/kernel/trap.c	
+++ b/Offline 05/xv6-riscv/kernel/trap.c	
@@ -53,27 +53,54 @@ usertrap(void)
   if(r_scause() == 8){
     // system call
 
-    if(killed(p))
+    if(p->killed)
       exit(-1);
 
     // sepc points to the ecall instruction,
     // but we want to return to the next instruction.
     p->trapframe->epc += 4;
 
-    // an interrupt will change sepc, scause, and sstatus,
-    // so enable only now that we're done with those registers.
+    // an interrupt will change sstatus &c registers,
+    // so don't enable until done with those registers.
     intr_on();
 
     syscall();
+    
   } else if((which_dev = devintr()) != 0){
-    // ok
+    // trap generated by CPU [system call, page fault]
+
   } else {
-    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
-    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
-    setkilled(p);
+    uint64 va = PGROUNDDOWN(r_stval());
+    if(va >= MAXVA){
+        p->killed = 1;
+        exit(-1);
+    }
+    pte_t* pte = walk(p->pagetable,va,0);
+    if(pte == 0){
+        p->killed = 1;
+        exit(-1);
+    }
+    uint64 pa = PTE2PA(*pte);
+    uint64 flag = PTE_FLAGS(*pte); 
+    if((r_scause() == 13 || r_scause() == 15) && (flag & PTE_RSW) ){
+        char* mem = kalloc();
+        if(mem == 0){
+            printf("here\n");
+            p->killed = 1;
+            exit(-1);
+        }
+        memmove(mem,(char*)pa,PGSIZE);
+        kfree((char*)pa);
+        *pte = PA2PTE(mem) | (flag & ~PTE_RSW) | PTE_W;
+    }
+    else{
+        printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
+        printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
+        p->killed = 1;
+    }
   }
 
-  if(killed(p))
+  if(p->killed)
     exit(-1);
 
   // give up the CPU if this is a timer interrupt.
diff --git a/Offline 05/xv6-riscv/kernel/vm.c b/Offline 05/xv6-riscv/kernel/vm.c
index 9f69783..c374f77 100644
--- a/Offline 05/xv6-riscv/kernel/vm.c	
+++ b/Offline 05/xv6-riscv/kernel/vm.c	
@@ -308,7 +308,7 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
   pte_t *pte;
   uint64 pa, i;
   uint flags;
-  char *mem;
+  // char *mem;
 
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walk(old, i, 0)) == 0)
@@ -316,14 +316,22 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
     if((*pte & PTE_V) == 0)
       panic("uvmcopy: page not present");
     pa = PTE2PA(*pte);
+    // flags = PTE_FLAGS(*pte);
+    // if((mem = kalloc()) == 0)
+    //   goto err;
+    // memmove(mem, (char*)pa, PGSIZE);
+    // if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
+    //   kfree(mem);
+    //   goto err;
+    // }
+
+    *pte = (*pte & ~PTE_W) | PTE_RSW;
     flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
-      goto err;
-    memmove(mem, (char*)pa, PGSIZE);
-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
-      kfree(mem);
+
+    if(mappages(new, i, PGSIZE, pa, flags) != 0) {
       goto err;
     }
+    add_rc(pa);
   }
   return 0;
 
@@ -351,11 +359,28 @@ uvmclear(pagetable_t pagetable, uint64 va)
 int
 copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
 {
-  uint64 n, va0, pa0;
+  uint64 n, va0, pa0, flag;
+  pte_t* pte;
 
   while(len > 0){
     va0 = PGROUNDDOWN(dstva);
-    pa0 = walkaddr(pagetable, va0);
+    if(va0 >= MAXVA)
+      return -1;
+    pte = walk(pagetable, va0, 0);
+    if(pte == 0)
+      return -1;
+    pa0 = PTE2PA(*pte);
+    flag = PTE_FLAGS(*pte);
+    if(flag & PTE_RSW) {
+      char* mem = kalloc();
+      if(mem == 0)
+        return -1;
+      memmove(mem, (char*)pa0, PGSIZE);
+      kfree((char*)pa0);
+      *pte = PA2PTE((uint64)mem) | (flag & ~PTE_RSW) | PTE_W;
+      pa0 = (uint64)mem;
+    }
+      
     if(pa0 == 0)
       return -1;
     n = PGSIZE - (dstva - va0);
